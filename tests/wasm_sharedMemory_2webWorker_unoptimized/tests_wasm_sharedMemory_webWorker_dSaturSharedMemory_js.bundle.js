/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkperformance_tests_multithreaded_webassembly"] = self["webpackChunkperformance_tests_multithreaded_webassembly"] || []).push([["tests_wasm_sharedMemory_webWorker_dSaturSharedMemory_js"],{

/***/ "./tests/wasm_sharedMemory_webWorker/dSaturSharedMemory.js":
/*!*****************************************************************!*\
  !*** ./tests/wasm_sharedMemory_webWorker/dSaturSharedMemory.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var __filename = \"/index.js\";\nvar __dirname = \"/\";\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n// Support for growable heap + pthreads, where the buffer may change, so JS views\n// must be updated.\nfunction GROWABLE_HEAP_I8() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAP8;\n}\nfunction GROWABLE_HEAP_U8() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAPU8;\n}\nfunction GROWABLE_HEAP_I16() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAP16;\n}\nfunction GROWABLE_HEAP_U16() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAPU16;\n}\nfunction GROWABLE_HEAP_I32() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAP32;\n}\nfunction GROWABLE_HEAP_U32() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAPU32;\n}\nfunction GROWABLE_HEAP_F32() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAPF32;\n}\nfunction GROWABLE_HEAP_F64() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAPF64;\n}\nvar Module = typeof Module != \"undefined\" ? Module : {};\nvar moduleOverrides = Object.assign({}, Module);\nvar arguments_ = [];\nvar thisProgram = \"./this.program\";\nvar quit_ = function quit_(status, toThrow) {\n  throw toThrow;\n};\nvar ENVIRONMENT_IS_WEB = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) == \"object\";\nvar ENVIRONMENT_IS_WORKER = typeof importScripts == \"function\";\nvar ENVIRONMENT_IS_NODE = (typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) == \"object\" && _typeof(process.versions) == \"object\" && typeof process.versions.node == \"string\";\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\nif (Module[\"ENVIRONMENT\"]) {\n  throw new Error(\"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)\");\n}\nvar ENVIRONMENT_IS_PTHREAD = Module[\"ENVIRONMENT_IS_PTHREAD\"] || false;\nvar _scriptDir = typeof document != \"undefined\" && document.currentScript ? document.currentScript.src : undefined;\nif (ENVIRONMENT_IS_WORKER) {\n  _scriptDir = self.location.href;\n} else if (ENVIRONMENT_IS_NODE) {\n  _scriptDir = __filename;\n}\nvar scriptDirectory = \"\";\nfunction locateFile(path) {\n  if (Module[\"locateFile\"]) {\n    return Module[\"locateFile\"](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\nvar read_, readAsync, readBinary;\nif (ENVIRONMENT_IS_NODE) {\n  if (typeof process == \"undefined\" || !process.release || process.release.name !== \"node\") throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\n  var nodeVersion = process.versions.node;\n  var numericVersion = nodeVersion.split(\".\").slice(0, 3);\n  numericVersion = numericVersion[0] * 1e4 + numericVersion[1] * 100 + numericVersion[2].split(\"-\")[0] * 1;\n  var minVersion = 16e4;\n  if (numericVersion < 16e4) {\n    throw new Error(\"This emscripten-generated code requires node v16.0.0 (detected v\" + nodeVersion + \")\");\n  }\n  var fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n  var nodePath = __webpack_require__(/*! path */ \"./node_modules/path/path.js\");\n  if (ENVIRONMENT_IS_WORKER) {\n    scriptDirectory = nodePath.dirname(scriptDirectory) + \"/\";\n  } else {\n    scriptDirectory = __dirname + \"/\";\n  }\n  read_ = function read_(filename, binary) {\n    filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\n    return fs.readFileSync(filename, binary ? undefined : \"utf8\");\n  };\n  readBinary = function readBinary(filename) {\n    var ret = read_(filename, true);\n    if (!ret.buffer) {\n      ret = new Uint8Array(ret);\n    }\n    assert(ret.buffer);\n    return ret;\n  };\n  readAsync = function readAsync(filename, onload, onerror) {\n    var binary = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\n    fs.readFile(filename, binary ? undefined : \"utf8\", function (err, data) {\n      if (err) onerror(err);else onload(binary ? data.buffer : data);\n    });\n  };\n  if (!Module[\"thisProgram\"] && process.argv.length > 1) {\n    thisProgram = process.argv[1].replace(/\\\\/g, \"/\");\n  }\n  arguments_ = process.argv.slice(2);\n  if (true) {\n    module[\"exports\"] = Module;\n  }\n  process.on(\"uncaughtException\", function (ex) {\n    if (ex !== \"unwind\" && !(ex instanceof ExitStatus) && !(ex.context instanceof ExitStatus)) {\n      throw ex;\n    }\n  });\n  quit_ = function quit_(status, toThrow) {\n    process.exitCode = status;\n    throw toThrow;\n  };\n  Module[\"inspect\"] = function () {\n    return \"[Emscripten Module object]\";\n  };\n  var nodeWorkerThreads;\n  try {\n    nodeWorkerThreads = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'worker_threads'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n  } catch (e) {\n    console.error('The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?');\n    throw e;\n  }\n  __webpack_require__.g.Worker = nodeWorkerThreads.Worker;\n} else if (ENVIRONMENT_IS_SHELL) {\n  if ((typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) == \"object\" && \"function\" === \"function\" || (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) == \"object\" || typeof importScripts == \"function\") throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\n  if (typeof read != \"undefined\") {\n    read_ = read;\n  }\n  readBinary = function readBinary(f) {\n    if (typeof readbuffer == \"function\") {\n      return new Uint8Array(readbuffer(f));\n    }\n    var data = read(f, \"binary\");\n    assert(_typeof(data) == \"object\");\n    return data;\n  };\n  readAsync = function readAsync(f, onload, onerror) {\n    setTimeout(function () {\n      return onload(readBinary(f));\n    });\n  };\n  if (typeof clearTimeout == \"undefined\") {\n    globalThis.clearTimeout = function (id) {};\n  }\n  if (typeof setTimeout == \"undefined\") {\n    globalThis.setTimeout = function (f) {\n      return typeof f == \"function\" ? f() : abort();\n    };\n  }\n  if (typeof scriptArgs != \"undefined\") {\n    arguments_ = scriptArgs;\n  } else if (typeof arguments != \"undefined\") {\n    arguments_ = arguments;\n  }\n  if (typeof quit == \"function\") {\n    quit_ = function quit_(status, toThrow) {\n      setTimeout(function () {\n        if (!(toThrow instanceof ExitStatus)) {\n          var toLog = toThrow;\n          if (toThrow && _typeof(toThrow) == \"object\" && toThrow.stack) {\n            toLog = [toThrow, toThrow.stack];\n          }\n          err(\"exiting due to exception: \".concat(toLog));\n        }\n        quit(status);\n      });\n      throw toThrow;\n    };\n  }\n  if (typeof print != \"undefined\") {\n    if (typeof console == \"undefined\") console = /** @type{!Console} */{};\n    console.log = /** @type{!function(this:Console, ...*): undefined} */print;\n    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */typeof printErr != \"undefined\" ? printErr : print;\n  }\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WORKER) {\n    scriptDirectory = self.location.href;\n  } else if (typeof document != \"undefined\" && document.currentScript) {\n    scriptDirectory = document.currentScript.src;\n  }\n  if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n  } else {\n    scriptDirectory = \"\";\n  }\n  if (!((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) == \"object\" || typeof importScripts == \"function\")) throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\n  if (!ENVIRONMENT_IS_NODE) {\n    read_ = function read_(url) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", url, false);\n      xhr.send(null);\n      return xhr.responseText;\n    };\n    if (ENVIRONMENT_IS_WORKER) {\n      readBinary = function readBinary(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url, false);\n        xhr.responseType = \"arraybuffer\";\n        xhr.send(null);\n        return new Uint8Array( /** @type{!ArrayBuffer} */xhr.response);\n      };\n    }\n    readAsync = function readAsync(url, onload, onerror) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", url, true);\n      xhr.responseType = \"arraybuffer\";\n      xhr.onload = function () {\n        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n          onload(xhr.response);\n          return;\n        }\n        onerror();\n      };\n      xhr.onerror = onerror;\n      xhr.send(null);\n    };\n  }\n} else {\n  throw new Error(\"environment detection error\");\n}\nif (ENVIRONMENT_IS_NODE) {\n  if (typeof performance == \"undefined\") {\n    __webpack_require__.g.performance = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'perf_hooks'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n  }\n}\nvar defaultPrint = console.log.bind(console);\nvar defaultPrintErr = console.error.bind(console);\nif (ENVIRONMENT_IS_NODE) {\n  defaultPrint = function defaultPrint() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return fs.writeSync(1, args.join(\" \") + \"\\n\");\n  };\n  defaultPrintErr = function defaultPrintErr() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return fs.writeSync(2, args.join(\" \") + \"\\n\");\n  };\n}\nvar out = Module[\"print\"] || defaultPrint;\nvar err = Module[\"printErr\"] || defaultPrintErr;\nObject.assign(Module, moduleOverrides);\nmoduleOverrides = null;\ncheckIncomingModuleAPI();\nif (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\nlegacyModuleProp(\"arguments\", \"arguments_\");\nif (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\nlegacyModuleProp(\"thisProgram\", \"thisProgram\");\nif (Module[\"quit\"]) quit_ = Module[\"quit\"];\nlegacyModuleProp(\"quit\", \"quit_\");\nassert(typeof Module[\"memoryInitializerPrefixURL\"] == \"undefined\", \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\");\nassert(typeof Module[\"pthreadMainPrefixURL\"] == \"undefined\", \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\");\nassert(typeof Module[\"cdInitializerPrefixURL\"] == \"undefined\", \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\");\nassert(typeof Module[\"filePackagePrefixURL\"] == \"undefined\", \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\");\nassert(typeof Module[\"read\"] == \"undefined\", \"Module.read option was removed (modify read_ in JS)\");\nassert(typeof Module[\"readAsync\"] == \"undefined\", \"Module.readAsync option was removed (modify readAsync in JS)\");\nassert(typeof Module[\"readBinary\"] == \"undefined\", \"Module.readBinary option was removed (modify readBinary in JS)\");\nassert(typeof Module[\"setWindowTitle\"] == \"undefined\", \"Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)\");\nassert(typeof Module[\"TOTAL_MEMORY\"] == \"undefined\", \"Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY\");\nlegacyModuleProp(\"asm\", \"wasmExports\");\nlegacyModuleProp(\"read\", \"read_\");\nlegacyModuleProp(\"readAsync\", \"readAsync\");\nlegacyModuleProp(\"readBinary\", \"readBinary\");\nlegacyModuleProp(\"setWindowTitle\", \"setWindowTitle\");\nvar IDBFS = \"IDBFS is no longer included by default; build with -lidbfs.js\";\nvar PROXYFS = \"PROXYFS is no longer included by default; build with -lproxyfs.js\";\nvar WORKERFS = \"WORKERFS is no longer included by default; build with -lworkerfs.js\";\nvar FETCHFS = \"FETCHFS is no longer included by default; build with -lfetchfs.js\";\nvar ICASEFS = \"ICASEFS is no longer included by default; build with -licasefs.js\";\nvar JSFILEFS = \"JSFILEFS is no longer included by default; build with -ljsfilefs.js\";\nvar OPFS = \"OPFS is no longer included by default; build with -lopfs.js\";\nvar NODEFS = \"NODEFS is no longer included by default; build with -lnodefs.js\";\nassert(ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER || ENVIRONMENT_IS_NODE, \"Pthreads do not work in this environment yet (need Web Workers, or an alternative to them)\");\nassert(!ENVIRONMENT_IS_SHELL, \"shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.\");\nvar wasmBinary;\nif (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\nlegacyModuleProp(\"wasmBinary\", \"wasmBinary\");\nif ((typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) != \"object\") {\n  abort(\"no native wasm support detected\");\n}\nvar wasmMemory;\nvar wasmModule;\nvar ABORT = false;\nvar EXITSTATUS;\n\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort(\"Assertion failed\" + (text ? \": \" + text : \"\"));\n  }\n}\nvar HEAP, /** @type {!Int8Array} */HEAP8, /** @type {!Uint8Array} */HEAPU8, /** @type {!Int16Array} */HEAP16, /** @type {!Uint16Array} */HEAPU16, /** @type {!Int32Array} */HEAP32, /** @type {!Uint32Array} */HEAPU32, /** @type {!Float32Array} */HEAPF32, /** @type {!Float64Array} */HEAPF64;\nfunction updateMemoryViews() {\n  var b = wasmMemory.buffer;\n  Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n  Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n  Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n  Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n  Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n  Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n  Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n  Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n}\nassert(!Module[\"STACK_SIZE\"], \"STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time\");\nassert(typeof Int32Array != \"undefined\" && typeof Float64Array !== \"undefined\" && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined, \"JS engine does not provide full typed array support\");\nvar INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 16777216;\nlegacyModuleProp(\"INITIAL_MEMORY\", \"INITIAL_MEMORY\");\nassert(INITIAL_MEMORY >= 65536, \"INITIAL_MEMORY should be larger than STACK_SIZE, was \" + INITIAL_MEMORY + \"! (STACK_SIZE=\" + 65536 + \")\");\nif (ENVIRONMENT_IS_PTHREAD) {\n  wasmMemory = Module[\"wasmMemory\"];\n} else {\n  if (Module[\"wasmMemory\"]) {\n    wasmMemory = Module[\"wasmMemory\"];\n  } else {\n    wasmMemory = new WebAssembly.Memory({\n      \"initial\": INITIAL_MEMORY / 65536,\n      \"maximum\": 2147483648 / 65536,\n      \"shared\": true\n    });\n    if (!(wasmMemory.buffer instanceof SharedArrayBuffer)) {\n      err(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\");\n      if (ENVIRONMENT_IS_NODE) {\n        err(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)\");\n      }\n      throw Error(\"bad memory\");\n    }\n  }\n}\nupdateMemoryViews();\nINITIAL_MEMORY = wasmMemory.buffer.byteLength;\nassert(INITIAL_MEMORY % 65536 === 0);\nfunction writeStackCookie() {\n  var max = _emscripten_stack_get_end2();\n  assert((max & 3) == 0);\n  if (max == 0) {\n    max += 4;\n  }\n  GROWABLE_HEAP_U32()[max >> 2] = 34821223;\n  GROWABLE_HEAP_U32()[max + 4 >> 2] = 2310721022;\n  GROWABLE_HEAP_U32()[0 >> 2] = 1668509029;\n}\nfunction checkStackCookie() {\n  if (ABORT) return;\n  var max = _emscripten_stack_get_end2();\n  if (max == 0) {\n    max += 4;\n  }\n  var cookie1 = GROWABLE_HEAP_U32()[max >> 2];\n  var cookie2 = GROWABLE_HEAP_U32()[max + 4 >> 2];\n  if (cookie1 != 34821223 || cookie2 != 2310721022) {\n    abort(\"Stack overflow! Stack cookie has been overwritten at \".concat(ptrToString(max), \", expected hex dwords 0x89BACDFE and 0x2135467, but received \").concat(ptrToString(cookie2), \" \").concat(ptrToString(cookie1)));\n  }\n  if (GROWABLE_HEAP_U32()[0 >> 2] != 1668509029) /* 'emsc' */{\n      abort(\"Runtime error: The application has corrupted its heap memory area (address zero)!\");\n    }\n}\n(function () {\n  var h16 = new Int16Array(1);\n  var h8 = new Int8Array(h16.buffer);\n  h16[0] = 25459;\n  if (h8[0] !== 115 || h8[1] !== 99) throw \"Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)\";\n})();\nvar __ATPRERUN__ = [];\nvar __ATINIT__ = [];\nvar __ATEXIT__ = [];\nvar __ATPOSTRUN__ = [];\nvar runtimeInitialized = false;\nfunction preRun() {\n  assert(!ENVIRONMENT_IS_PTHREAD);\n  if (Module[\"preRun\"]) {\n    if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n    while (Module[\"preRun\"].length) {\n      addOnPreRun(Module[\"preRun\"].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPRERUN__);\n}\nfunction initRuntime() {\n  assert(!runtimeInitialized);\n  runtimeInitialized = true;\n  if (ENVIRONMENT_IS_PTHREAD) return;\n  checkStackCookie();\n  callRuntimeCallbacks(__ATINIT__);\n}\nfunction postRun() {\n  checkStackCookie();\n  if (ENVIRONMENT_IS_PTHREAD) return;\n  if (Module[\"postRun\"]) {\n    if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n    while (Module[\"postRun\"].length) {\n      addOnPostRun(Module[\"postRun\"].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\nfunction addOnExit(cb) {}\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\nassert(Math.imul, \"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\nassert(Math.fround, \"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\nassert(Math.clz32, \"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\nassert(Math.trunc, \"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null;\nvar runDependencyTracking = {};\nfunction getUniqueRunDependency(id) {\n  var orig = id;\n  while (1) {\n    if (!runDependencyTracking[id]) return id;\n    id = orig + Math.random();\n  }\n}\nfunction addRunDependency(id) {\n  runDependencies++;\n  if (Module[\"monitorRunDependencies\"]) {\n    Module[\"monitorRunDependencies\"](runDependencies);\n  }\n  if (id) {\n    assert(!runDependencyTracking[id]);\n    runDependencyTracking[id] = 1;\n    if (runDependencyWatcher === null && typeof setInterval != \"undefined\") {\n      runDependencyWatcher = setInterval(function () {\n        if (ABORT) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n          return;\n        }\n        var shown = false;\n        for (var dep in runDependencyTracking) {\n          if (!shown) {\n            shown = true;\n            err(\"still waiting on run dependencies:\");\n          }\n          err(\"dependency: \".concat(dep));\n        }\n        if (shown) {\n          err(\"(end of list)\");\n        }\n      }, 1e4);\n    }\n  } else {\n    err(\"warning: run dependency added without ID\");\n  }\n}\nfunction removeRunDependency(id) {\n  runDependencies--;\n  if (Module[\"monitorRunDependencies\"]) {\n    Module[\"monitorRunDependencies\"](runDependencies);\n  }\n  if (id) {\n    assert(runDependencyTracking[id]);\n    delete runDependencyTracking[id];\n  } else {\n    err(\"warning: run dependency removed without ID\");\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback();\n    }\n  }\n}\n\n/** @param {string|number=} what */\nfunction abort(what) {\n  if (Module[\"onAbort\"]) {\n    Module[\"onAbort\"](what);\n  }\n  what = \"Aborted(\" + what + \")\";\n  err(what);\n  ABORT = true;\n  EXITSTATUS = 1;\n  /** @suppress {checkTypes} */\n  var e = new WebAssembly.RuntimeError(what);\n  throw e;\n}\nvar FS = {\n  error: function error() {\n    abort(\"Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM\");\n  },\n  init: function init() {\n    FS.error();\n  },\n  createDataFile: function createDataFile() {\n    FS.error();\n  },\n  createPreloadedFile: function createPreloadedFile() {\n    FS.error();\n  },\n  createLazyFile: function createLazyFile() {\n    FS.error();\n  },\n  open: function open() {\n    FS.error();\n  },\n  mkdev: function mkdev() {\n    FS.error();\n  },\n  registerDevice: function registerDevice() {\n    FS.error();\n  },\n  analyzePath: function analyzePath() {\n    FS.error();\n  },\n  ErrnoError: function ErrnoError() {\n    FS.error();\n  }\n};\nModule[\"FS_createDataFile\"] = FS.createDataFile;\nModule[\"FS_createPreloadedFile\"] = FS.createPreloadedFile;\nvar dataURIPrefix = \"data:application/octet-stream;base64,\";\n\n/**\r\n * Indicates whether filename is a base64 data URI.\r\n * @noinline\r\n */\nvar isDataURI = function isDataURI(filename) {\n  return filename.startsWith(dataURIPrefix);\n};\n\n/**\r\n * Indicates whether filename is delivered via file protocol (as opposed to http/https)\r\n * @noinline\r\n */\nvar isFileURI = function isFileURI(filename) {\n  return filename.startsWith(\"file://\");\n};\nfunction createExportWrapper(name) {\n  return function () {\n    assert(runtimeInitialized, \"native function `\".concat(name, \"` called before runtime initialization\"));\n    var f = wasmExports[name];\n    assert(f, \"exported native function `\".concat(name, \"` not found\"));\n    return f.apply(null, arguments);\n  };\n}\nvar wasmBinaryFile;\nwasmBinaryFile = \"dSaturSharedMemory.wasm\";\nif (!isDataURI(wasmBinaryFile)) {\n  wasmBinaryFile = locateFile(wasmBinaryFile);\n}\nfunction getBinarySync(file) {\n  if (file == wasmBinaryFile && wasmBinary) {\n    return new Uint8Array(wasmBinary);\n  }\n  if (readBinary) {\n    return readBinary(file);\n  }\n  throw \"both async and sync fetching of the wasm failed\";\n}\nfunction getBinaryPromise(binaryFile) {\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n    if (typeof fetch == \"function\" && !isFileURI(binaryFile)) {\n      return fetch(binaryFile, {\n        credentials: \"same-origin\"\n      }).then(function (response) {\n        if (!response[\"ok\"]) {\n          throw \"failed to load wasm binary file at '\" + binaryFile + \"'\";\n        }\n        return response[\"arrayBuffer\"]();\n      })[\"catch\"](function () {\n        return getBinarySync(binaryFile);\n      });\n    } else if (readAsync) {\n      return new Promise(function (resolve, reject) {\n        readAsync(binaryFile, function (response) {\n          return resolve(new Uint8Array( /** @type{!ArrayBuffer} */response));\n        }, reject);\n      });\n    }\n  }\n  return Promise.resolve().then(function () {\n    return getBinarySync(binaryFile);\n  });\n}\nfunction instantiateArrayBuffer(binaryFile, imports, receiver) {\n  return getBinaryPromise(binaryFile).then(function (binary) {\n    return WebAssembly.instantiate(binary, imports);\n  }).then(function (instance) {\n    return instance;\n  }).then(receiver, function (reason) {\n    err(\"failed to asynchronously prepare wasm: \".concat(reason));\n    if (isFileURI(wasmBinaryFile)) {\n      err(\"warning: Loading from a file URI (\".concat(wasmBinaryFile, \") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing\"));\n    }\n    abort(reason);\n  });\n}\nfunction instantiateAsync(binary, binaryFile, imports, callback) {\n  if (!binary && typeof WebAssembly.instantiateStreaming == \"function\" && !isDataURI(binaryFile) && !isFileURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == \"function\") {\n    return fetch(binaryFile, {\n      credentials: \"same-origin\"\n    }).then(function (response) {\n      /** @suppress {checkTypes} */var result = WebAssembly.instantiateStreaming(response, imports);\n      return result.then(callback, function (reason) {\n        err(\"wasm streaming compile failed: \".concat(reason));\n        err(\"falling back to ArrayBuffer instantiation\");\n        return instantiateArrayBuffer(binaryFile, imports, callback);\n      });\n    });\n  }\n  return instantiateArrayBuffer(binaryFile, imports, callback);\n}\nfunction createWasm() {\n  var info = {\n    \"env\": wasmImports,\n    \"wasi_snapshot_preview1\": wasmImports\n  };\n  /** @param {WebAssembly.Module=} module*/\n  function receiveInstance(instance, module) {\n    wasmExports = instance.exports;\n    registerTLSInit(wasmExports[\"_emscripten_tls_init\"]);\n    wasmTable = wasmExports[\"__indirect_function_table\"];\n    assert(wasmTable, \"table not found in wasm exports\");\n    addOnInit(wasmExports[\"__wasm_call_ctors\"]);\n    wasmModule = module;\n    removeRunDependency(\"wasm-instantiate\");\n    return wasmExports;\n  }\n  addRunDependency(\"wasm-instantiate\");\n  var trueModule = Module;\n  function receiveInstantiationResult(result) {\n    assert(Module === trueModule, \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\");\n    trueModule = null;\n    receiveInstance(result[\"instance\"], result[\"module\"]);\n  }\n  if (Module[\"instantiateWasm\"]) {\n    try {\n      return Module[\"instantiateWasm\"](info, receiveInstance);\n    } catch (e) {\n      err(\"Module.instantiateWasm callback failed with error: \".concat(e));\n      return false;\n    }\n  }\n  instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);\n  return {};\n}\nvar tempDouble;\nvar tempI64;\nfunction legacyModuleProp(prop, newName) {\n  var incomming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!Object.getOwnPropertyDescriptor(Module, prop)) {\n    Object.defineProperty(Module, prop, {\n      configurable: true,\n      get: function get() {\n        var extra = incomming ? \" (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\" : \"\";\n        abort(\"`Module.\".concat(prop, \"` has been replaced by `\").concat(newName, \"`\") + extra);\n      }\n    });\n  }\n}\nfunction ignoredModuleProp(prop) {\n  if (Object.getOwnPropertyDescriptor(Module, prop)) {\n    abort(\"`Module.\".concat(prop, \"` was supplied but `\").concat(prop, \"` not included in INCOMING_MODULE_JS_API\"));\n  }\n}\nfunction isExportedByForceFilesystem(name) {\n  return name === \"FS_createPath\" || name === \"FS_createDataFile\" || name === \"FS_createPreloadedFile\" || name === \"FS_unlink\" || name === \"addRunDependency\" || name === \"FS_createLazyFile\" || name === \"FS_createDevice\" || name === \"removeRunDependency\";\n}\nfunction missingGlobal(sym, msg) {\n  if (typeof globalThis !== \"undefined\") {\n    Object.defineProperty(globalThis, sym, {\n      configurable: true,\n      get: function get() {\n        warnOnce(\"`\" + sym + \"` is not longer defined by emscripten. \" + msg);\n        return undefined;\n      }\n    });\n  }\n}\nmissingGlobal(\"buffer\", \"Please use HEAP8.buffer or wasmMemory.buffer\");\nmissingGlobal(\"asm\", \"Please use wasmExports instead\");\nfunction missingLibrarySymbol(sym) {\n  if (typeof globalThis !== \"undefined\" && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\n    Object.defineProperty(globalThis, sym, {\n      configurable: true,\n      get: function get() {\n        var msg = \"`\" + sym + \"` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line\";\n        var librarySymbol = sym;\n        if (!librarySymbol.startsWith(\"_\")) {\n          librarySymbol = \"$\" + sym;\n        }\n        msg += \" (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='\" + librarySymbol + \"')\";\n        if (isExportedByForceFilesystem(sym)) {\n          msg += \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\n        }\n        warnOnce(msg);\n        return undefined;\n      }\n    });\n  }\n  unexportedRuntimeSymbol(sym);\n}\nfunction unexportedRuntimeSymbol(sym) {\n  if (!Object.getOwnPropertyDescriptor(Module, sym)) {\n    Object.defineProperty(Module, sym, {\n      configurable: true,\n      get: function get() {\n        var msg = \"'\" + sym + \"' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)\";\n        if (isExportedByForceFilesystem(sym)) {\n          msg += \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\n        }\n        abort(msg);\n      }\n    });\n  }\n}\nfunction dbg(text) {\n  if (ENVIRONMENT_IS_NODE) {\n    fs.writeSync(2, Array.from(arguments).join(\" \") + \"\\n\");\n  } else console.warn.apply(console, arguments);\n}\nfunction changeNodeColorJS(nodeKey, newColorCode, thread) {\n  Module.changeNodeColor(nodeKey, newColorCode, thread);\n}\nfunction threadsFinishedJS() {\n  Module.threadsFinished();\n}\n\n/** @constructor */\nfunction ExitStatus(status) {\n  this.name = \"ExitStatus\";\n  this.message = \"Program terminated with exit(\".concat(status, \")\");\n  this.status = status;\n}\nvar terminateWorker = function terminateWorker(worker) {\n  worker.terminate();\n  worker.onmessage = function (e) {\n    var cmd = e[\"data\"][\"cmd\"];\n    err(\"received \\\"\".concat(cmd, \"\\\" command from terminated worker: \").concat(worker.workerID));\n  };\n};\nvar killThread = function killThread(pthread_ptr) {\n  assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! killThread() can only ever be called from main application thread!\");\n  assert(pthread_ptr, \"Internal Error! Null pthread_ptr in killThread!\");\n  var worker = PThread.pthreads[pthread_ptr];\n  delete PThread.pthreads[pthread_ptr];\n  terminateWorker(worker);\n  __emscripten_thread_free_data(pthread_ptr);\n  PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);\n  worker.pthread_ptr = 0;\n};\nvar cancelThread = function cancelThread(pthread_ptr) {\n  assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! cancelThread() can only ever be called from main application thread!\");\n  assert(pthread_ptr, \"Internal Error! Null pthread_ptr in cancelThread!\");\n  var worker = PThread.pthreads[pthread_ptr];\n  worker.postMessage({\n    \"cmd\": \"cancel\"\n  });\n};\nvar cleanupThread = function cleanupThread(pthread_ptr) {\n  assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! cleanupThread() can only ever be called from main application thread!\");\n  assert(pthread_ptr, \"Internal Error! Null pthread_ptr in cleanupThread!\");\n  var worker = PThread.pthreads[pthread_ptr];\n  assert(worker);\n  PThread.returnWorkerToPool(worker);\n};\nvar zeroMemory = function zeroMemory(address, size) {\n  GROWABLE_HEAP_U8().fill(0, address, address + size);\n  return address;\n};\nvar spawnThread = function spawnThread(threadParams) {\n  assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! spawnThread() can only ever be called from main application thread!\");\n  assert(threadParams.pthread_ptr, \"Internal error, no pthread ptr!\");\n  var worker = PThread.getNewWorker();\n  if (!worker) {\n    return 6;\n  }\n  assert(!worker.pthread_ptr, \"Internal error!\");\n  PThread.runningWorkers.push(worker);\n  PThread.pthreads[threadParams.pthread_ptr] = worker;\n  worker.pthread_ptr = threadParams.pthread_ptr;\n  var msg = {\n    \"cmd\": \"run\",\n    \"start_routine\": threadParams.startRoutine,\n    \"arg\": threadParams.arg,\n    \"pthread_ptr\": threadParams.pthread_ptr\n  };\n  if (ENVIRONMENT_IS_NODE) {\n    worker.unref();\n  }\n  worker.postMessage(msg, threadParams.transferList);\n  return 0;\n};\nvar runtimeKeepaliveCounter = 0;\nvar keepRuntimeAlive = function keepRuntimeAlive() {\n  return noExitRuntime || runtimeKeepaliveCounter > 0;\n};\nvar UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\n/**\r\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\r\n     * array that contains uint8 values, returns a copy of that string as a\r\n     * Javascript String object.\r\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\r\n     * @param {number} idx\r\n     * @param {number=} maxBytesToRead\r\n     * @return {string}\r\n     */\nvar UTF8ArrayToString = function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n  var endIdx = idx + maxBytesToRead;\n  var endPtr = idx;\n  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n    return UTF8Decoder.decode(heapOrArray.buffer instanceof SharedArrayBuffer ? heapOrArray.slice(idx, endPtr) : heapOrArray.subarray(idx, endPtr));\n  }\n  var str = \"\";\n  while (idx < endPtr) {\n    var u0 = heapOrArray[idx++];\n    if (!(u0 & 128)) {\n      str += String.fromCharCode(u0);\n      continue;\n    }\n    var u1 = heapOrArray[idx++] & 63;\n    if ((u0 & 224) == 192) {\n      str += String.fromCharCode((u0 & 31) << 6 | u1);\n      continue;\n    }\n    var u2 = heapOrArray[idx++] & 63;\n    if ((u0 & 240) == 224) {\n      u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n    } else {\n      if ((u0 & 248) != 240) warnOnce(\"Invalid UTF-8 leading byte \" + ptrToString(u0) + \" encountered when deserializing a UTF-8 string in wasm memory to a JS string!\");\n      u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n    }\n    if (u0 < 65536) {\n      str += String.fromCharCode(u0);\n    } else {\n      var ch = u0 - 65536;\n      str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n    }\n  }\n  return str;\n};\n\n/**\r\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\r\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\r\n     *\r\n     * @param {number} ptr\r\n     * @param {number=} maxBytesToRead - An optional length that specifies the\r\n     *   maximum number of bytes to read. You can omit this parameter to scan the\r\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\r\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\r\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\r\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\r\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\r\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\r\n     * @return {string}\r\n     */\nvar UTF8ToString = function UTF8ToString(ptr, maxBytesToRead) {\n  assert(typeof ptr == \"number\", \"UTF8ToString expects a number (got \".concat(_typeof(ptr), \")\"));\n  return ptr ? UTF8ArrayToString(GROWABLE_HEAP_U8(), ptr, maxBytesToRead) : \"\";\n};\nvar SYSCALLS = {\n  varargs: undefined,\n  get: function get() {\n    assert(SYSCALLS.varargs != undefined);\n    var ret = GROWABLE_HEAP_I32()[+SYSCALLS.varargs >> 2];\n    SYSCALLS.varargs += 4;\n    return ret;\n  },\n  getp: function getp() {\n    return SYSCALLS.get();\n  },\n  getStr: function getStr(ptr) {\n    var ret = UTF8ToString(ptr);\n    return ret;\n  }\n};\nvar withStackSave = function withStackSave(f) {\n  var stack = stackSave();\n  var ret = f();\n  stackRestore(stack);\n  return ret;\n};\nvar convertI32PairToI53Checked = function convertI32PairToI53Checked(lo, hi) {\n  assert(lo == lo >>> 0 || lo == (lo | 0));\n  assert(hi === (hi | 0));\n  return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;\n};\n\n/** @type{function(number, (number|boolean), ...(number|boolean))} */\nvar proxyToMainThread = function proxyToMainThread(index, sync) {\n  var numCallArgs = arguments.length - 2;\n  var outerArgs = arguments;\n  return withStackSave(function () {\n    var serializedNumCallArgs = numCallArgs;\n    var args = stackAlloc(serializedNumCallArgs * 8);\n    var b = args >> 3;\n    for (var i = 0; i < numCallArgs; i++) {\n      var arg = outerArgs[2 + i];\n      GROWABLE_HEAP_F64()[b + i] = arg;\n    }\n    return __emscripten_run_on_main_thread_js(index, serializedNumCallArgs, args, sync);\n  });\n};\nfunction _proc_exit(code) {\n  if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(0, 1, code);\n  EXITSTATUS = code;\n  if (!keepRuntimeAlive()) {\n    PThread.terminateAllThreads();\n    if (Module[\"onExit\"]) Module[\"onExit\"](code);\n    ABORT = true;\n  }\n  quit_(code, new ExitStatus(code));\n}\n\n/** @param {boolean|number=} implicit */\nvar exitJS = function exitJS(status, implicit) {\n  EXITSTATUS = status;\n  checkUnflushedContent();\n  if (ENVIRONMENT_IS_PTHREAD) {\n    assert(!implicit);\n    exitOnMainThread(status);\n    throw \"unwind\";\n  }\n  if (keepRuntimeAlive() && !implicit) {\n    var msg = \"program exited (with status: \".concat(status, \"), but keepRuntimeAlive() is set (counter=\").concat(runtimeKeepaliveCounter, \") due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)\");\n    err(msg);\n  }\n  _proc_exit(status);\n};\nvar _exit = exitJS;\nvar ptrToString = function ptrToString(ptr) {\n  assert(typeof ptr === \"number\");\n  ptr >>>= 0;\n  return \"0x\" + ptr.toString(16).padStart(8, \"0\");\n};\nvar handleException = function handleException(e) {\n  if (e instanceof ExitStatus || e == \"unwind\") {\n    return EXITSTATUS;\n  }\n  checkStackCookie();\n  if (e instanceof WebAssembly.RuntimeError) {\n    if (_emscripten_stack_get_current2() <= 0) {\n      err(\"Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 65536)\");\n    }\n  }\n  quit_(1, e);\n};\nvar PThread = {\n  unusedWorkers: [],\n  runningWorkers: [],\n  tlsInitFunctions: [],\n  pthreads: {},\n  nextWorkerID: 1,\n  debugInit: function debugInit() {\n    function pthreadLogPrefix() {\n      var t = 0;\n      if (runtimeInitialized && typeof _pthread_self != \"undefined\") {\n        t = _pthread_self();\n      }\n      return \"w:\" + (Module[\"workerID\"] || 0) + \",t:\" + ptrToString(t) + \": \";\n    }\n    var origDbg = dbg;\n    dbg = function dbg(message) {\n      return origDbg(pthreadLogPrefix() + message);\n    };\n  },\n  init: function init() {\n    PThread.debugInit();\n    if (ENVIRONMENT_IS_PTHREAD) {\n      PThread.initWorker();\n    } else {\n      PThread.initMainThread();\n    }\n  },\n  initMainThread: function initMainThread() {\n    addOnPreRun(function () {\n      addRunDependency(\"loading-workers\");\n      PThread.loadWasmModuleToAllWorkers(function () {\n        return removeRunDependency(\"loading-workers\");\n      });\n    });\n  },\n  initWorker: function initWorker() {\n    PThread[\"receiveObjectTransfer\"] = PThread.receiveObjectTransfer;\n    PThread[\"threadInitTLS\"] = PThread.threadInitTLS;\n    PThread[\"setExitStatus\"] = PThread.setExitStatus;\n    noExitRuntime = false;\n  },\n  setExitStatus: function setExitStatus(status) {\n    EXITSTATUS = status;\n  },\n  terminateAllThreads__deps: [\"$terminateWorker\"],\n  terminateAllThreads: function terminateAllThreads() {\n    assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! terminateAllThreads() can only ever be called from main application thread!\");\n    var _iterator = _createForOfIteratorHelper(PThread.runningWorkers),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var worker = _step.value;\n        terminateWorker(worker);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var _iterator2 = _createForOfIteratorHelper(PThread.unusedWorkers),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var worker = _step2.value;\n        terminateWorker(worker);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    PThread.unusedWorkers = [];\n    PThread.runningWorkers = [];\n    PThread.pthreads = [];\n  },\n  returnWorkerToPool: function returnWorkerToPool(worker) {\n    var pthread_ptr = worker.pthread_ptr;\n    delete PThread.pthreads[pthread_ptr];\n    PThread.unusedWorkers.push(worker);\n    PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);\n    worker.pthread_ptr = 0;\n    __emscripten_thread_free_data(pthread_ptr);\n  },\n  receiveObjectTransfer: function receiveObjectTransfer(data) {},\n  threadInitTLS: function threadInitTLS() {\n    PThread.tlsInitFunctions.forEach(function (f) {\n      return f();\n    });\n  },\n  loadWasmModuleToWorker: function loadWasmModuleToWorker(worker) {\n    return new Promise(function (onFinishedLoading) {\n      worker.onmessage = function (e) {\n        var d = e[\"data\"];\n        var cmd = d[\"cmd\"];\n        if (d[\"targetThread\"] && d[\"targetThread\"] != _pthread_self()) {\n          var targetWorker = PThread.pthreads[d[\"targetThread\"]];\n          if (targetWorker) {\n            targetWorker.postMessage(d, d[\"transferList\"]);\n          } else {\n            err(\"Internal error! Worker sent a message \\\"\".concat(cmd, \"\\\" to target pthread \").concat(d[\"targetThread\"], \", but that thread no longer exists!\"));\n          }\n          return;\n        }\n        if (cmd === \"checkMailbox\") {\n          checkMailbox();\n        } else if (cmd === \"spawnThread\") {\n          spawnThread(d);\n        } else if (cmd === \"cleanupThread\") {\n          cleanupThread(d[\"thread\"]);\n        } else if (cmd === \"killThread\") {\n          killThread(d[\"thread\"]);\n        } else if (cmd === \"cancelThread\") {\n          cancelThread(d[\"thread\"]);\n        } else if (cmd === \"loaded\") {\n          worker.loaded = true;\n          onFinishedLoading(worker);\n        } else if (cmd === \"alert\") {\n          alert(\"Thread \".concat(d[\"threadId\"], \": \").concat(d[\"text\"]));\n        } else if (d.target === \"setimmediate\") {\n          worker.postMessage(d);\n        } else if (cmd === \"callHandler\") {\n          Module[d[\"handler\"]].apply(Module, _toConsumableArray(d[\"args\"]));\n        } else if (cmd) {\n          err(\"worker sent an unknown command \".concat(cmd));\n        }\n      };\n      worker.onerror = function (e) {\n        var message = \"worker sent an error!\";\n        if (worker.pthread_ptr) {\n          message = \"Pthread \".concat(ptrToString(worker.pthread_ptr), \" sent an error!\");\n        }\n        err(\"\".concat(message, \" \").concat(e.filename, \":\").concat(e.lineno, \": \").concat(e.message));\n        throw e;\n      };\n      if (ENVIRONMENT_IS_NODE) {\n        worker.on(\"message\", function (data) {\n          return worker.onmessage({\n            data: data\n          });\n        });\n        worker.on(\"error\", function (e) {\n          return worker.onerror(e);\n        });\n      }\n      assert(wasmMemory instanceof WebAssembly.Memory, \"WebAssembly memory should have been loaded by now!\");\n      assert(wasmModule instanceof WebAssembly.Module, \"WebAssembly Module should have been loaded by now!\");\n      var handlers = [];\n      var knownHandlers = [\"onExit\", \"onAbort\", \"print\", \"printErr\"];\n      for (var _i = 0, _knownHandlers = knownHandlers; _i < _knownHandlers.length; _i++) {\n        var handler = _knownHandlers[_i];\n        if (Module.hasOwnProperty(handler)) {\n          handlers.push(handler);\n        }\n      }\n      worker.workerID = PThread.nextWorkerID++;\n      worker.postMessage({\n        \"cmd\": \"load\",\n        \"handlers\": handlers,\n        \"urlOrBlob\": Module[\"mainScriptUrlOrBlob\"] || _scriptDir,\n        \"wasmMemory\": wasmMemory,\n        \"wasmModule\": wasmModule,\n        \"workerID\": worker.workerID\n      });\n    });\n  },\n  loadWasmModuleToAllWorkers: function loadWasmModuleToAllWorkers(onMaybeReady) {\n    onMaybeReady();\n  },\n  allocateUnusedWorker: function allocateUnusedWorker() {\n    var worker;\n    var pthreadMainJs = locateFile(\"dSaturSharedMemory.worker.js\");\n    worker = new Worker(pthreadMainJs);\n    PThread.unusedWorkers.push(worker);\n  },\n  getNewWorker: function getNewWorker() {\n    if (PThread.unusedWorkers.length == 0) {\n      if (!ENVIRONMENT_IS_NODE) {\n        err(\"Tried to spawn a new thread, but the thread pool is exhausted.\\n\" + \"This might result in a deadlock unless some threads eventually exit or the code explicitly breaks out to the event loop.\\n\" + \"If you want to increase the pool size, use setting `-sPTHREAD_POOL_SIZE=...`.\" + \"\\nIf you want to throw an explicit error instead of the risk of deadlocking in those cases, use setting `-sPTHREAD_POOL_SIZE_STRICT=2`.\");\n      }\n      PThread.allocateUnusedWorker();\n      PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]);\n    }\n    return PThread.unusedWorkers.pop();\n  }\n};\nModule[\"PThread\"] = PThread;\nvar callRuntimeCallbacks = function callRuntimeCallbacks(callbacks) {\n  while (callbacks.length > 0) {\n    callbacks.shift()(Module);\n  }\n};\nvar establishStackSpace = function establishStackSpace() {\n  var pthread_ptr = _pthread_self();\n  var stackHigh = GROWABLE_HEAP_U32()[pthread_ptr + 52 >> 2];\n  var stackSize = GROWABLE_HEAP_U32()[pthread_ptr + 56 >> 2];\n  var stackLow = stackHigh - stackSize;\n  assert(stackHigh != 0);\n  assert(stackLow != 0);\n  assert(stackHigh > stackLow, \"stackHigh must be higher then stackLow\");\n  _emscripten_stack_set_limits2(stackHigh, stackLow);\n  stackRestore(stackHigh);\n  writeStackCookie();\n};\nModule[\"establishStackSpace\"] = establishStackSpace;\nfunction exitOnMainThread(returnCode) {\n  if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(1, 0, returnCode);\n  _exit(returnCode);\n}\n\n/**\r\n     * @param {number} ptr\r\n     * @param {string} type\r\n     */\nfunction getValue(ptr) {\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"i8\";\n  if (type.endsWith(\"*\")) type = \"*\";\n  switch (type) {\n    case \"i1\":\n      return GROWABLE_HEAP_I8()[ptr >> 0];\n    case \"i8\":\n      return GROWABLE_HEAP_I8()[ptr >> 0];\n    case \"i16\":\n      return GROWABLE_HEAP_I16()[ptr >> 1];\n    case \"i32\":\n      return GROWABLE_HEAP_I32()[ptr >> 2];\n    case \"i64\":\n      abort(\"to do getValue(i64) use WASM_BIGINT\");\n    case \"float\":\n      return GROWABLE_HEAP_F32()[ptr >> 2];\n    case \"double\":\n      return GROWABLE_HEAP_F64()[ptr >> 3];\n    case \"*\":\n      return GROWABLE_HEAP_U32()[ptr >> 2];\n    default:\n      abort(\"invalid type for getValue: \".concat(type));\n  }\n}\nvar wasmTableMirror = [];\nvar wasmTable;\nvar getWasmTableEntry = function getWasmTableEntry(funcPtr) {\n  var func = wasmTableMirror[funcPtr];\n  if (!func) {\n    if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n    wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n  }\n  assert(wasmTable.get(funcPtr) == func, \"JavaScript-side Wasm function table mirror is out of date!\");\n  return func;\n};\nvar invokeEntryPoint = function invokeEntryPoint(ptr, arg) {\n  var result = getWasmTableEntry(ptr)(arg);\n  checkStackCookie();\n  function finish(result) {\n    if (keepRuntimeAlive()) {\n      PThread.setExitStatus(result);\n    } else {\n      __emscripten_thread_exit(result);\n    }\n  }\n  finish(result);\n};\nModule[\"invokeEntryPoint\"] = invokeEntryPoint;\nvar noExitRuntime = Module[\"noExitRuntime\"] || true;\nvar registerTLSInit = function registerTLSInit(tlsInitFunc) {\n  PThread.tlsInitFunctions.push(tlsInitFunc);\n};\n\n/**\r\n     * @param {number} ptr\r\n     * @param {number} value\r\n     * @param {string} type\r\n     */\nfunction setValue(ptr, value) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"i8\";\n  if (type.endsWith(\"*\")) type = \"*\";\n  switch (type) {\n    case \"i1\":\n      GROWABLE_HEAP_I8()[ptr >> 0] = value;\n      break;\n    case \"i8\":\n      GROWABLE_HEAP_I8()[ptr >> 0] = value;\n      break;\n    case \"i16\":\n      GROWABLE_HEAP_I16()[ptr >> 1] = value;\n      break;\n    case \"i32\":\n      GROWABLE_HEAP_I32()[ptr >> 2] = value;\n      break;\n    case \"i64\":\n      abort(\"to do setValue(i64) use WASM_BIGINT\");\n    case \"float\":\n      GROWABLE_HEAP_F32()[ptr >> 2] = value;\n      break;\n    case \"double\":\n      GROWABLE_HEAP_F64()[ptr >> 3] = value;\n      break;\n    case \"*\":\n      GROWABLE_HEAP_U32()[ptr >> 2] = value;\n      break;\n    default:\n      abort(\"invalid type for setValue: \".concat(type));\n  }\n}\nvar warnOnce = function warnOnce(text) {\n  if (!warnOnce.shown) warnOnce.shown = {};\n  if (!warnOnce.shown[text]) {\n    warnOnce.shown[text] = 1;\n    if (ENVIRONMENT_IS_NODE) text = \"warning: \" + text;\n    err(text);\n  }\n};\nvar ___assert_fail = function ___assert_fail(condition, filename, line, func) {\n  abort(\"Assertion failed: \".concat(UTF8ToString(condition), \", at: \") + [filename ? UTF8ToString(filename) : \"unknown filename\", line, func ? UTF8ToString(func) : \"unknown function\"]);\n};\n\n/** @constructor */\nfunction ExceptionInfo(excPtr) {\n  this.excPtr = excPtr;\n  this.ptr = excPtr - 24;\n  this.set_type = function (type) {\n    GROWABLE_HEAP_U32()[this.ptr + 4 >> 2] = type;\n  };\n  this.get_type = function () {\n    return GROWABLE_HEAP_U32()[this.ptr + 4 >> 2];\n  };\n  this.set_destructor = function (destructor) {\n    GROWABLE_HEAP_U32()[this.ptr + 8 >> 2] = destructor;\n  };\n  this.get_destructor = function () {\n    return GROWABLE_HEAP_U32()[this.ptr + 8 >> 2];\n  };\n  this.set_caught = function (caught) {\n    caught = caught ? 1 : 0;\n    GROWABLE_HEAP_I8()[this.ptr + 12 >> 0] = caught;\n  };\n  this.get_caught = function () {\n    return GROWABLE_HEAP_I8()[this.ptr + 12 >> 0] != 0;\n  };\n  this.set_rethrown = function (rethrown) {\n    rethrown = rethrown ? 1 : 0;\n    GROWABLE_HEAP_I8()[this.ptr + 13 >> 0] = rethrown;\n  };\n  this.get_rethrown = function () {\n    return GROWABLE_HEAP_I8()[this.ptr + 13 >> 0] != 0;\n  };\n  this.init = function (type, destructor) {\n    this.set_adjusted_ptr(0);\n    this.set_type(type);\n    this.set_destructor(destructor);\n  };\n  this.set_adjusted_ptr = function (adjustedPtr) {\n    GROWABLE_HEAP_U32()[this.ptr + 16 >> 2] = adjustedPtr;\n  };\n  this.get_adjusted_ptr = function () {\n    return GROWABLE_HEAP_U32()[this.ptr + 16 >> 2];\n  };\n  this.get_exception_ptr = function () {\n    var isPointer = ___cxa_is_pointer_type(this.get_type());\n    if (isPointer) {\n      return GROWABLE_HEAP_U32()[this.excPtr >> 2];\n    }\n    var adjusted = this.get_adjusted_ptr();\n    if (adjusted !== 0) return adjusted;\n    return this.excPtr;\n  };\n}\nvar exceptionLast = 0;\nvar uncaughtExceptionCount = 0;\nvar ___cxa_throw = function ___cxa_throw(ptr, type, destructor) {\n  var info = new ExceptionInfo(ptr);\n  info.init(type, destructor);\n  exceptionLast = ptr;\n  uncaughtExceptionCount++;\n  assert(false, \"Exception thrown, but exception catching is not enabled. Compile with -sNO_DISABLE_EXCEPTION_CATCHING or -sEXCEPTION_CATCHING_ALLOWED=[..] to catch.\");\n};\nvar ___emscripten_init_main_thread_js = function ___emscripten_init_main_thread_js(tb) {\n  __emscripten_thread_init(tb, /*is_main=*/!ENVIRONMENT_IS_WORKER, /*is_runtime=*/1, /*can_block=*/!ENVIRONMENT_IS_WEB, /*default_stacksize=*/65536, /*start_profiling=*/false);\n  PThread.threadInitTLS();\n};\nvar ___emscripten_thread_cleanup = function ___emscripten_thread_cleanup(thread) {\n  if (!ENVIRONMENT_IS_PTHREAD) cleanupThread(thread);else postMessage({\n    \"cmd\": \"cleanupThread\",\n    \"thread\": thread\n  });\n};\nvar nowIsMonotonic = true;\nvar __emscripten_get_now_is_monotonic = function __emscripten_get_now_is_monotonic() {\n  return nowIsMonotonic;\n};\nvar maybeExit = function maybeExit() {\n  if (!keepRuntimeAlive()) {\n    try {\n      if (ENVIRONMENT_IS_PTHREAD) __emscripten_thread_exit(EXITSTATUS);else _exit(EXITSTATUS);\n    } catch (e) {\n      handleException(e);\n    }\n  }\n};\nvar callUserCallback = function callUserCallback(func) {\n  if (ABORT) {\n    err(\"user callback triggered after runtime exited or application aborted.  Ignoring.\");\n    return;\n  }\n  try {\n    func();\n    maybeExit();\n  } catch (e) {\n    handleException(e);\n  }\n};\nvar __emscripten_thread_mailbox_await = function __emscripten_thread_mailbox_await(pthread_ptr) {\n  if (typeof Atomics.waitAsync === \"function\") {\n    var wait = Atomics.waitAsync(GROWABLE_HEAP_I32(), pthread_ptr >> 2, pthread_ptr);\n    assert(wait.async);\n    wait.value.then(checkMailbox);\n    var waitingAsync = pthread_ptr + 128;\n    Atomics.store(GROWABLE_HEAP_I32(), waitingAsync >> 2, 1);\n  }\n};\nModule[\"__emscripten_thread_mailbox_await\"] = __emscripten_thread_mailbox_await;\nvar checkMailbox = function checkMailbox() {\n  var pthread_ptr = _pthread_self();\n  if (pthread_ptr) {\n    __emscripten_thread_mailbox_await(pthread_ptr);\n    callUserCallback(__emscripten_check_mailbox);\n  }\n};\nModule[\"checkMailbox\"] = checkMailbox;\nvar __emscripten_notify_mailbox_postmessage = function __emscripten_notify_mailbox_postmessage(targetThreadId, currThreadId, mainThreadId) {\n  if (targetThreadId == currThreadId) {\n    setTimeout(function () {\n      return checkMailbox();\n    });\n  } else if (ENVIRONMENT_IS_PTHREAD) {\n    postMessage({\n      \"targetThread\": targetThreadId,\n      \"cmd\": \"checkMailbox\"\n    });\n  } else {\n    var worker = PThread.pthreads[targetThreadId];\n    if (!worker) {\n      err(\"Cannot send message to thread with ID \".concat(targetThreadId, \", unknown thread ID!\"));\n      return;\n    }\n    worker.postMessage({\n      \"cmd\": \"checkMailbox\"\n    });\n  }\n};\nvar proxiedJSCallArgs = [];\nvar __emscripten_receive_on_main_thread_js = function __emscripten_receive_on_main_thread_js(index, callingThread, numCallArgs, args) {\n  proxiedJSCallArgs.length = numCallArgs;\n  var b = args >> 3;\n  for (var i = 0; i < numCallArgs; i++) {\n    proxiedJSCallArgs[i] = GROWABLE_HEAP_F64()[b + i];\n  }\n  var func = proxiedFunctionTable[index];\n  assert(func.length == numCallArgs, \"Call args mismatch in _emscripten_receive_on_main_thread_js\");\n  PThread.currentProxiedOperationCallerThread = callingThread;\n  var rtn = func.apply(null, proxiedJSCallArgs);\n  PThread.currentProxiedOperationCallerThread = 0;\n  assert(typeof rtn != \"bigint\");\n  return rtn;\n};\nvar __emscripten_thread_set_strongref = function __emscripten_thread_set_strongref(thread) {\n  if (ENVIRONMENT_IS_NODE) {\n    PThread.pthreads[thread].ref();\n  }\n};\nvar _abort = function _abort() {\n  abort(\"native code called abort()\");\n};\nvar _emscripten_check_blocking_allowed = function _emscripten_check_blocking_allowed() {\n  if (ENVIRONMENT_IS_NODE) return;\n  if (ENVIRONMENT_IS_WORKER) return;\n  warnOnce(\"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\");\n};\nvar _emscripten_date_now = function _emscripten_date_now() {\n  return Date.now();\n};\nvar runtimeKeepalivePush = function runtimeKeepalivePush() {\n  runtimeKeepaliveCounter += 1;\n};\nvar _emscripten_exit_with_live_runtime = function _emscripten_exit_with_live_runtime() {\n  runtimeKeepalivePush();\n  throw \"unwind\";\n};\nvar _emscripten_get_now;\n_emscripten_get_now = function _emscripten_get_now() {\n  return performance.timeOrigin + performance.now();\n};\nvar getHeapMax = function getHeapMax() {\n  return 2147483648;\n};\nvar growMemory = function growMemory(size) {\n  var b = wasmMemory.buffer;\n  var pages = (size - b.byteLength + 65535) / 65536;\n  try {\n    wasmMemory.grow(pages);\n    updateMemoryViews();\n    return 1;\n  } /*success*/ catch (e) {\n    err(\"growMemory: Attempted to grow heap from \".concat(b.byteLength, \" bytes to \").concat(size, \" bytes, but got error: \").concat(e));\n  }\n};\nvar _emscripten_resize_heap = function _emscripten_resize_heap(requestedSize) {\n  var oldSize = GROWABLE_HEAP_U8().length;\n  requestedSize >>>= 0;\n  if (requestedSize <= oldSize) {\n    return false;\n  }\n  var maxHeapSize = getHeapMax();\n  if (requestedSize > maxHeapSize) {\n    err(\"Cannot enlarge memory, requested \".concat(requestedSize, \" bytes, but the limit is \").concat(maxHeapSize, \" bytes!\"));\n    return false;\n  }\n  var alignUp = function alignUp(x, multiple) {\n    return x + (multiple - x % multiple) % multiple;\n  };\n  for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n    var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n    var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n    var replacement = growMemory(newSize);\n    if (replacement) {\n      return true;\n    }\n  }\n  err(\"Failed to grow the heap from \".concat(oldSize, \" bytes to \").concat(newSize, \" bytes, not enough memory!\"));\n  return false;\n};\nfunction _fd_close(fd) {\n  if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(2, 1, fd);\n  abort(\"fd_close called without SYSCALLS_REQUIRE_FILESYSTEM\");\n}\nfunction _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n  if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(3, 1, fd, offset_low, offset_high, whence, newOffset);\n  var offset = convertI32PairToI53Checked(offset_low, offset_high);\n  return 70;\n}\nvar printCharBuffers = [null, [], []];\nvar printChar = function printChar(stream, curr) {\n  var buffer = printCharBuffers[stream];\n  assert(buffer);\n  if (curr === 0 || curr === 10) {\n    (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n    buffer.length = 0;\n  } else {\n    buffer.push(curr);\n  }\n};\nvar flush_NO_FILESYSTEM = function flush_NO_FILESYSTEM() {\n  _fflush(0);\n  if (printCharBuffers[1].length) printChar(1, 10);\n  if (printCharBuffers[2].length) printChar(2, 10);\n};\nfunction _fd_write(fd, iov, iovcnt, pnum) {\n  if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(4, 1, fd, iov, iovcnt, pnum);\n  var num = 0;\n  for (var i = 0; i < iovcnt; i++) {\n    var ptr = GROWABLE_HEAP_U32()[iov >> 2];\n    var len = GROWABLE_HEAP_U32()[iov + 4 >> 2];\n    iov += 8;\n    for (var j = 0; j < len; j++) {\n      printChar(fd, GROWABLE_HEAP_U8()[ptr + j]);\n    }\n    num += len;\n  }\n  GROWABLE_HEAP_U32()[pnum >> 2] = num;\n  return 0;\n}\nvar getCFunc = function getCFunc(ident) {\n  var func = Module[\"_\" + ident];\n  assert(func, \"Cannot call unknown function \" + ident + \", make sure it is exported\");\n  return func;\n};\nvar writeArrayToMemory = function writeArrayToMemory(array, buffer) {\n  assert(array.length >= 0, \"writeArrayToMemory array must have a length (should be an array or typed array)\");\n  GROWABLE_HEAP_I8().set(array, buffer);\n};\nvar lengthBytesUTF8 = function lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    var c = str.charCodeAt(i);\n    if (c <= 127) {\n      len++;\n    } else if (c <= 2047) {\n      len += 2;\n    } else if (c >= 55296 && c <= 57343) {\n      len += 4;\n      ++i;\n    } else {\n      len += 3;\n    }\n  }\n  return len;\n};\nvar stringToUTF8Array = function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n  assert(typeof str === \"string\", \"stringToUTF8Array expects a string (got \".concat(_typeof(str), \")\"));\n  if (!(maxBytesToWrite > 0)) return 0;\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1;\n  for (var i = 0; i < str.length; ++i) {\n    var u = str.charCodeAt(i);\n    if (u >= 55296 && u <= 57343) {\n      var u1 = str.charCodeAt(++i);\n      u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n    }\n    if (u <= 127) {\n      if (outIdx >= endIdx) break;\n      heap[outIdx++] = u;\n    } else if (u <= 2047) {\n      if (outIdx + 1 >= endIdx) break;\n      heap[outIdx++] = 192 | u >> 6;\n      heap[outIdx++] = 128 | u & 63;\n    } else if (u <= 65535) {\n      if (outIdx + 2 >= endIdx) break;\n      heap[outIdx++] = 224 | u >> 12;\n      heap[outIdx++] = 128 | u >> 6 & 63;\n      heap[outIdx++] = 128 | u & 63;\n    } else {\n      if (outIdx + 3 >= endIdx) break;\n      if (u > 1114111) warnOnce(\"Invalid Unicode code point \" + ptrToString(u) + \" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).\");\n      heap[outIdx++] = 240 | u >> 18;\n      heap[outIdx++] = 128 | u >> 12 & 63;\n      heap[outIdx++] = 128 | u >> 6 & 63;\n      heap[outIdx++] = 128 | u & 63;\n    }\n  }\n  heap[outIdx] = 0;\n  return outIdx - startIdx;\n};\nvar stringToUTF8 = function stringToUTF8(str, outPtr, maxBytesToWrite) {\n  assert(typeof maxBytesToWrite == \"number\", \"stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n  return stringToUTF8Array(str, GROWABLE_HEAP_U8(), outPtr, maxBytesToWrite);\n};\nvar stringToUTF8OnStack = function stringToUTF8OnStack(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8(str, ret, size);\n  return ret;\n};\n\n/**\r\n     * @param {string|null=} returnType\r\n     * @param {Array=} argTypes\r\n     * @param {Arguments|Array=} args\r\n     * @param {Object=} opts\r\n     */\nvar ccall = function ccall(ident, returnType, argTypes, args, opts) {\n  var toC = {\n    \"string\": function string(str) {\n      var ret = 0;\n      if (str !== null && str !== undefined && str !== 0) {\n        ret = stringToUTF8OnStack(str);\n      }\n      return ret;\n    },\n    \"array\": function array(arr) {\n      var ret = stackAlloc(arr.length);\n      writeArrayToMemory(arr, ret);\n      return ret;\n    }\n  };\n  function convertReturnValue(ret) {\n    if (returnType === \"string\") {\n      return UTF8ToString(ret);\n    }\n    if (returnType === \"boolean\") return Boolean(ret);\n    return ret;\n  }\n  var func = getCFunc(ident);\n  var cArgs = [];\n  var stack = 0;\n  assert(returnType !== \"array\", 'Return type should not be \"array\".');\n  if (args) {\n    for (var i = 0; i < args.length; i++) {\n      var converter = toC[argTypes[i]];\n      if (converter) {\n        if (stack === 0) stack = stackSave();\n        cArgs[i] = converter(args[i]);\n      } else {\n        cArgs[i] = args[i];\n      }\n    }\n  }\n  var ret = func.apply(null, cArgs);\n  function onDone(ret) {\n    if (stack !== 0) stackRestore(stack);\n    return convertReturnValue(ret);\n  }\n  ret = onDone(ret);\n  return ret;\n};\n\n/**\r\n     * @param {string=} returnType\r\n     * @param {Array=} argTypes\r\n     * @param {Object=} opts\r\n     */\nvar cwrap = function cwrap(ident, returnType, argTypes, opts) {\n  return function () {\n    return ccall(ident, returnType, argTypes, arguments, opts);\n  };\n};\nPThread.init();\nvar proxiedFunctionTable = [_proc_exit, exitOnMainThread, _fd_close, _fd_seek, _fd_write];\nfunction checkIncomingModuleAPI() {\n  ignoredModuleProp(\"fetchSettings\");\n}\nvar wasmImports = {\n  /** @export */__assert_fail: ___assert_fail,\n  /** @export */__cxa_throw: ___cxa_throw,\n  /** @export */__emscripten_init_main_thread_js: ___emscripten_init_main_thread_js,\n  /** @export */__emscripten_thread_cleanup: ___emscripten_thread_cleanup,\n  /** @export */_emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,\n  /** @export */_emscripten_notify_mailbox_postmessage: __emscripten_notify_mailbox_postmessage,\n  /** @export */_emscripten_receive_on_main_thread_js: __emscripten_receive_on_main_thread_js,\n  /** @export */_emscripten_thread_mailbox_await: __emscripten_thread_mailbox_await,\n  /** @export */_emscripten_thread_set_strongref: __emscripten_thread_set_strongref,\n  /** @export */abort: _abort,\n  /** @export */changeNodeColorJS: changeNodeColorJS,\n  /** @export */emscripten_check_blocking_allowed: _emscripten_check_blocking_allowed,\n  /** @export */emscripten_date_now: _emscripten_date_now,\n  /** @export */emscripten_exit_with_live_runtime: _emscripten_exit_with_live_runtime,\n  /** @export */emscripten_get_now: _emscripten_get_now,\n  /** @export */emscripten_resize_heap: _emscripten_resize_heap,\n  /** @export */exit: _exit,\n  /** @export */fd_close: _fd_close,\n  /** @export */fd_seek: _fd_seek,\n  /** @export */fd_write: _fd_write,\n  /** @export */memory: wasmMemory,\n  /** @export */threadsFinishedJS: threadsFinishedJS\n};\nvar wasmExports = createWasm();\nvar ___wasm_call_ctors = createExportWrapper(\"__wasm_call_ctors\");\nvar _processGraph = Module[\"_processGraph\"] = createExportWrapper(\"processGraph\");\nvar _initializeData = Module[\"_initializeData\"] = createExportWrapper(\"initializeData\");\nvar __emscripten_tls_init = Module[\"__emscripten_tls_init\"] = createExportWrapper(\"_emscripten_tls_init\");\nvar _pthread_self = Module[\"_pthread_self\"] = function () {\n  return (_pthread_self = Module[\"_pthread_self\"] = wasmExports[\"pthread_self\"])();\n};\nvar ___errno_location = createExportWrapper(\"__errno_location\");\nvar __emscripten_thread_init = Module[\"__emscripten_thread_init\"] = createExportWrapper(\"_emscripten_thread_init\");\nvar __emscripten_thread_crashed = Module[\"__emscripten_thread_crashed\"] = createExportWrapper(\"_emscripten_thread_crashed\");\nvar _fflush = Module[\"_fflush\"] = createExportWrapper(\"fflush\");\nvar _emscripten_main_runtime_thread_id = createExportWrapper(\"emscripten_main_runtime_thread_id\");\nvar _emscripten_main_thread_process_queued_calls = createExportWrapper(\"emscripten_main_thread_process_queued_calls\");\nvar __emscripten_run_on_main_thread_js = createExportWrapper(\"_emscripten_run_on_main_thread_js\");\nvar __emscripten_thread_free_data = createExportWrapper(\"_emscripten_thread_free_data\");\nvar __emscripten_thread_exit = Module[\"__emscripten_thread_exit\"] = createExportWrapper(\"_emscripten_thread_exit\");\nvar __emscripten_check_mailbox = createExportWrapper(\"_emscripten_check_mailbox\");\nvar _malloc = Module[\"_malloc\"] = createExportWrapper(\"malloc\");\nvar _free = Module[\"_free\"] = createExportWrapper(\"free\");\nvar _emscripten_stack_get_base2 = function _emscripten_stack_get_base() {\n  return (_emscripten_stack_get_base2 = wasmExports[\"emscripten_stack_get_base\"])();\n};\nvar _emscripten_stack_get_end2 = function _emscripten_stack_get_end() {\n  return (_emscripten_stack_get_end2 = wasmExports[\"emscripten_stack_get_end\"])();\n};\nvar _emscripten_stack_init2 = function _emscripten_stack_init() {\n  return (_emscripten_stack_init2 = wasmExports[\"emscripten_stack_init\"])();\n};\nvar _emscripten_stack_set_limits2 = function _emscripten_stack_set_limits(a0, a1) {\n  return (_emscripten_stack_set_limits2 = wasmExports[\"emscripten_stack_set_limits\"])(a0, a1);\n};\nvar _emscripten_stack_get_free2 = function _emscripten_stack_get_free() {\n  return (_emscripten_stack_get_free2 = wasmExports[\"emscripten_stack_get_free\"])();\n};\nvar stackSave = createExportWrapper(\"stackSave\");\nvar stackRestore = createExportWrapper(\"stackRestore\");\nvar stackAlloc = createExportWrapper(\"stackAlloc\");\nvar _emscripten_stack_get_current2 = function _emscripten_stack_get_current() {\n  return (_emscripten_stack_get_current2 = wasmExports[\"emscripten_stack_get_current\"])();\n};\nvar ___cxa_is_pointer_type = createExportWrapper(\"__cxa_is_pointer_type\");\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = createExportWrapper(\"dynCall_jiji\");\nvar ___start_em_js = Module[\"___start_em_js\"] = 68072;\nvar ___stop_em_js = Module[\"___stop_em_js\"] = 68214;\nModule[\"run\"] = run;\nModule[\"wasmMemory\"] = wasmMemory;\nModule[\"keepRuntimeAlive\"] = keepRuntimeAlive;\nModule[\"ccall\"] = ccall;\nModule[\"cwrap\"] = cwrap;\nModule[\"ExitStatus\"] = ExitStatus;\nvar missingLibrarySymbols = [\"writeI53ToI64\", \"writeI53ToI64Clamped\", \"writeI53ToI64Signaling\", \"writeI53ToU64Clamped\", \"writeI53ToU64Signaling\", \"readI53FromI64\", \"readI53FromU64\", \"convertI32PairToI53\", \"convertU32PairToI53\", \"isLeapYear\", \"ydayFromDate\", \"arraySum\", \"addDays\", \"setErrNo\", \"inetPton4\", \"inetNtop4\", \"inetPton6\", \"inetNtop6\", \"readSockaddr\", \"writeSockaddr\", \"getHostByName\", \"initRandomFill\", \"randomFill\", \"getCallstack\", \"emscriptenLog\", \"convertPCtoSourceLocation\", \"readEmAsmArgs\", \"jstoi_q\", \"jstoi_s\", \"getExecutableName\", \"listenOnce\", \"autoResumeAudioContext\", \"dynCallLegacy\", \"getDynCaller\", \"dynCall\", \"runtimeKeepalivePop\", \"asmjsMangle\", \"asyncLoad\", \"alignMemory\", \"mmapAlloc\", \"handleAllocatorInit\", \"HandleAllocator\", \"getNativeTypeSize\", \"STACK_SIZE\", \"STACK_ALIGN\", \"POINTER_SIZE\", \"ASSERTIONS\", \"uleb128Encode\", \"sigToWasmTypes\", \"generateFuncType\", \"convertJsFunctionToWasm\", \"getEmptyTableSlot\", \"updateTableMap\", \"getFunctionAddress\", \"addFunction\", \"removeFunction\", \"reallyNegative\", \"unSign\", \"strLen\", \"reSign\", \"formatString\", \"intArrayFromString\", \"intArrayToString\", \"AsciiToString\", \"stringToAscii\", \"UTF16ToString\", \"stringToUTF16\", \"lengthBytesUTF16\", \"UTF32ToString\", \"stringToUTF32\", \"lengthBytesUTF32\", \"stringToNewUTF8\", \"registerKeyEventCallback\", \"maybeCStringToJsString\", \"findEventTarget\", \"findCanvasEventTarget\", \"getBoundingClientRect\", \"fillMouseEventData\", \"registerMouseEventCallback\", \"registerWheelEventCallback\", \"registerUiEventCallback\", \"registerFocusEventCallback\", \"fillDeviceOrientationEventData\", \"registerDeviceOrientationEventCallback\", \"fillDeviceMotionEventData\", \"registerDeviceMotionEventCallback\", \"screenOrientation\", \"fillOrientationChangeEventData\", \"registerOrientationChangeEventCallback\", \"fillFullscreenChangeEventData\", \"registerFullscreenChangeEventCallback\", \"JSEvents_requestFullscreen\", \"JSEvents_resizeCanvasForFullscreen\", \"registerRestoreOldStyle\", \"hideEverythingExceptGivenElement\", \"restoreHiddenElements\", \"setLetterbox\", \"softFullscreenResizeWebGLRenderTarget\", \"doRequestFullscreen\", \"fillPointerlockChangeEventData\", \"registerPointerlockChangeEventCallback\", \"registerPointerlockErrorEventCallback\", \"requestPointerLock\", \"fillVisibilityChangeEventData\", \"registerVisibilityChangeEventCallback\", \"registerTouchEventCallback\", \"fillGamepadEventData\", \"registerGamepadEventCallback\", \"registerBeforeUnloadEventCallback\", \"fillBatteryEventData\", \"battery\", \"registerBatteryEventCallback\", \"setCanvasElementSizeCallingThread\", \"setCanvasElementSizeMainThread\", \"setCanvasElementSize\", \"getCanvasSizeCallingThread\", \"getCanvasSizeMainThread\", \"getCanvasElementSize\", \"demangle\", \"demangleAll\", \"jsStackTrace\", \"stackTrace\", \"getEnvStrings\", \"checkWasiClock\", \"wasiRightsToMuslOFlags\", \"wasiOFlagsToMuslOFlags\", \"createDyncallWrapper\", \"safeSetTimeout\", \"setImmediateWrapped\", \"clearImmediateWrapped\", \"polyfillSetImmediate\", \"getPromise\", \"makePromise\", \"idsToPromises\", \"makePromiseCallback\", \"findMatchingCatch\", \"setMainLoop\", \"getSocketFromFD\", \"getSocketAddress\", \"FS_createPreloadedFile\", \"FS_modeStringToFlags\", \"FS_getMode\", \"FS_stdin_getChar\", \"FS_createDataFile\", \"FS_unlink\", \"FS_mkdirTree\", \"_setNetworkCallback\", \"heapObjectForWebGLType\", \"heapAccessShiftForWebGLHeap\", \"webgl_enable_ANGLE_instanced_arrays\", \"webgl_enable_OES_vertex_array_object\", \"webgl_enable_WEBGL_draw_buffers\", \"webgl_enable_WEBGL_multi_draw\", \"emscriptenWebGLGet\", \"computeUnpackAlignedImageSize\", \"colorChannelsInGlTextureFormat\", \"emscriptenWebGLGetTexPixelData\", \"__glGenObject\", \"emscriptenWebGLGetUniform\", \"webglGetUniformLocation\", \"webglPrepareUniformLocationsBeforeFirstUse\", \"webglGetLeftBracePos\", \"emscriptenWebGLGetVertexAttrib\", \"__glGetActiveAttribOrUniform\", \"writeGLArray\", \"emscripten_webgl_destroy_context_before_on_calling_thread\", \"registerWebGlEventCallback\", \"runAndAbortIfError\", \"SDL_unicode\", \"SDL_ttfContext\", \"SDL_audio\", \"ALLOC_NORMAL\", \"ALLOC_STACK\", \"allocate\", \"writeStringToMemory\", \"writeAsciiToMemory\"];\nmissingLibrarySymbols.forEach(missingLibrarySymbol);\nvar unexportedSymbols = [\"addOnPreRun\", \"addOnInit\", \"addOnPreMain\", \"addOnExit\", \"addOnPostRun\", \"addRunDependency\", \"removeRunDependency\", \"FS_createFolder\", \"FS_createPath\", \"FS_createLazyFile\", \"FS_createLink\", \"FS_createDevice\", \"FS_readFile\", \"out\", \"err\", \"callMain\", \"abort\", \"wasmExports\", \"stackAlloc\", \"stackSave\", \"stackRestore\", \"getTempRet0\", \"setTempRet0\", \"GROWABLE_HEAP_I8\", \"GROWABLE_HEAP_U8\", \"GROWABLE_HEAP_I16\", \"GROWABLE_HEAP_U16\", \"GROWABLE_HEAP_I32\", \"GROWABLE_HEAP_U32\", \"GROWABLE_HEAP_F32\", \"GROWABLE_HEAP_F64\", \"writeStackCookie\", \"checkStackCookie\", \"convertI32PairToI53Checked\", \"ptrToString\", \"zeroMemory\", \"exitJS\", \"getHeapMax\", \"growMemory\", \"ENV\", \"MONTH_DAYS_REGULAR\", \"MONTH_DAYS_LEAP\", \"MONTH_DAYS_REGULAR_CUMULATIVE\", \"MONTH_DAYS_LEAP_CUMULATIVE\", \"ERRNO_CODES\", \"ERRNO_MESSAGES\", \"DNS\", \"Protocols\", \"Sockets\", \"timers\", \"warnOnce\", \"UNWIND_CACHE\", \"readEmAsmArgsArray\", \"handleException\", \"runtimeKeepalivePush\", \"callUserCallback\", \"maybeExit\", \"wasmTable\", \"noExitRuntime\", \"getCFunc\", \"freeTableIndexes\", \"functionsInTableMap\", \"setValue\", \"getValue\", \"PATH\", \"PATH_FS\", \"UTF8Decoder\", \"UTF8ArrayToString\", \"UTF8ToString\", \"stringToUTF8Array\", \"stringToUTF8\", \"lengthBytesUTF8\", \"UTF16Decoder\", \"stringToUTF8OnStack\", \"writeArrayToMemory\", \"JSEvents\", \"specialHTMLTargets\", \"currentFullscreenStrategy\", \"restoreOldWindowedStyle\", \"flush_NO_FILESYSTEM\", \"promiseMap\", \"uncaughtExceptionCount\", \"exceptionLast\", \"exceptionCaught\", \"ExceptionInfo\", \"Browser\", \"wget\", \"SYSCALLS\", \"preloadPlugins\", \"FS_stdin_getChar_buffer\", \"FS\", \"MEMFS\", \"TTY\", \"PIPEFS\", \"SOCKFS\", \"tempFixedLengthArray\", \"miniTempWebGLFloatBuffers\", \"miniTempWebGLIntBuffers\", \"GL\", \"emscripten_webgl_power_preferences\", \"AL\", \"GLUT\", \"EGL\", \"GLEW\", \"IDBStore\", \"SDL\", \"SDL_gfx\", \"allocateUTF8\", \"allocateUTF8OnStack\", \"PThread\", \"terminateWorker\", \"killThread\", \"cleanupThread\", \"registerTLSInit\", \"cancelThread\", \"spawnThread\", \"exitOnMainThread\", \"proxyToMainThread\", \"proxiedJSCallArgs\", \"invokeEntryPoint\", \"checkMailbox\"];\nunexportedSymbols.forEach(unexportedRuntimeSymbol);\nvar calledRun;\ndependenciesFulfilled = function runCaller() {\n  if (!calledRun) run();\n  if (!calledRun) dependenciesFulfilled = runCaller;\n};\nfunction stackCheckInit() {\n  assert(!ENVIRONMENT_IS_PTHREAD);\n  _emscripten_stack_init2();\n  writeStackCookie();\n}\nfunction run() {\n  if (runDependencies > 0) {\n    return;\n  }\n  if (!ENVIRONMENT_IS_PTHREAD) stackCheckInit();\n  if (ENVIRONMENT_IS_PTHREAD) {\n    initRuntime();\n    startWorker(Module);\n    return;\n  }\n  preRun();\n  if (runDependencies > 0) {\n    return;\n  }\n  function doRun() {\n    if (calledRun) return;\n    calledRun = true;\n    Module[\"calledRun\"] = true;\n    if (ABORT) return;\n    initRuntime();\n    if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n    assert(!Module[\"_main\"], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n    postRun();\n  }\n  if (Module[\"setStatus\"]) {\n    Module[\"setStatus\"](\"Running...\");\n    setTimeout(function () {\n      setTimeout(function () {\n        Module[\"setStatus\"](\"\");\n      }, 1);\n      doRun();\n    }, 1);\n  } else {\n    doRun();\n  }\n  checkStackCookie();\n}\nfunction checkUnflushedContent() {\n  var oldOut = out;\n  var oldErr = err;\n  var has = false;\n  out = err = function err(x) {\n    has = true;\n  };\n  try {\n    flush_NO_FILESYSTEM();\n  } catch (e) {}\n  out = oldOut;\n  err = oldErr;\n  if (has) {\n    warnOnce(\"stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.\");\n    warnOnce(\"(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)\");\n  }\n}\nif (Module[\"preInit\"]) {\n  if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n  while (Module[\"preInit\"].length > 0) {\n    Module[\"preInit\"].pop()();\n  }\n}\nrun();\n\n//# sourceURL=webpack://performance_tests_multithreaded_webassembly/./tests/wasm_sharedMemory_webWorker/dSaturSharedMemory.js?");

/***/ })

}]);